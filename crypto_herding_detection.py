# -*- coding: utf-8 -*-
"""Paper_4_Crypto_Herding_Detection_revision.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12urJkhLncBrYj724X-K8o1mUk-GnlNol

# **Importing Packages**
"""


import pandas as pd
import numpy as np
import plotly.express as px
import statsmodels.api as sm
import matplotlib.pyplot as plt

import itertools

def flatten_list(nested_list):
    return list(itertools.chain(*nested_list))

from google.colab import drive
drive.mount('/content/drive')

"""# **Reading Data**"""

# Read Cryptocurrency data
data_crypto = pd.read_csv("data/crypto_30min_filled_missing_value(ffill).csv")
data_crypto = data_crypto.set_index("date")

"""**Convert prices to returns**"""

# Find log-returns
names = data_crypto.columns
numpy_data = data_crypto.to_numpy()
original = numpy_data[:-1]
onelag = numpy_data[1:]
logreturns = np.log(onelag) - np.log(original)

return_data = pd.DataFrame(data = logreturns, columns = names)
return_data["date"] = data_crypto.index[1:]
return_data = return_data.set_index(['date'])

return_data_rm_UST = return_data.drop(columns = ["UST"]) # For the Ukraine-Russia period, as UST was no longer available at this time
names_rm_UST = return_data_rm_UST.columns

"""**Using 27 cryptocurrencies**"""

# Calculate the market return at each time point, i.e. the average return of all assets
market_return = pd.DataFrame(return_data.mean(axis=1), columns = ["mean market return"])
market_return.index = return_data.index

"""**Without UST**"""

# Calculate the market return at each time point, i.e. the average return of all assets
market_return = pd.DataFrame(return_data_rm_UST.mean(axis=1), columns = ["mean market return"])
market_return.index = return_data_rm_UST.index

fig_market_return = px.line(market_return, x='date', y= "mean market return", title='30-min market return')


"""**Using 27 cryptocurrencies**"""

num_assets = len(names)
market_return_repeat = pd.concat([market_return] * num_assets, axis=1, ignore_index=True)
market_return_repeat.columns = return_data.columns

"""**Without UST**"""

num_assets = len(names_rm_UST)
market_return_repeat = pd.concat([market_return] * num_assets, axis=1, ignore_index=True)
market_return_repeat.columns = return_data_rm_UST.columns

market_return_repeat

"""# **Herding Detection**

---


We use the Cross-Sectional Absolute Deviation (CSAD) model to detect the herding behavior in financial markets. This is one of the most well-known herding behavior detection approaches that has been used widely in many studies.

The fundamental idea of this technique is to examine the relationship between the average return (market return) of a set of assets and the dispersion across each asset return (CSAD). A herding signal is pronounced when the market return changes significantly (i.e. the market experiences large fluctuations, either going up or down) while the dispersion between asset returns decreases (i.e. the return movements of different assets become more similar). In this study, we use two forms of the CSAD model for our experiments.
+ $CSAD_t = \beta_0 + \beta_1|r_{m,t}| + \beta_2 r_{m,t}^2 + \epsilon_t$
+ $CSAD_t = \gamma_0 + \gamma_1 D^{up} |r_{m,t}| + \gamma_2 D^{up} r_{m,t}^2 + \gamma_3 D^{down} |r_{m,t}| + \gamma_4 D^{down} r_{m,t}^2 + \zeta_t$

Where $CSAD_t = \sum\limits_{k = 1}^T |r_{i,t} - r_{m,t}| / T$; $r_{i,t}$ is the return of asset $i$ at time $t$; $r_{m,t} = \sum\limits_{k = 1}^{N} r_{k,t} / N $ is the average of asset returns (also known as the market return) at time $t$; $\beta_0, \beta_1, \beta_2, \gamma_0, \gamma_1, \gamma_2, \gamma_3, \gamma_4$ are regression coefficients, $D^{up} = 1$ if $r_{m,t}$ is positive, otherwise $0$; $D^{down} = 1$ if $r_{m,t}$ is negative, otherwise $0$; $\epsilon_t, \zeta_t$ are error terms at time $t$.

Regarding the first equation, a herding exists when the parameter $\beta_2$ is significantly negative (a negative coefficient with a confidence level of at least 90\%). Intuitively, we expect this coefficient to be negative because it follows the idea of the herding behavior, i.e. a dramatic increase or decrease in the market return ($r_{m,t}^2$) coincides with a decline (negative $\beta_2$) in the dispersion between corresponding assets' returns ($CSAD_t$). The second equation refers to a more detailed version of the first one in which we separate the market condition into $\textit{up}$ (i.e. positive market return) and $\textit{down}$ (i.e. non-positive market return) so that the herding can be detected during the $\textit{up}$ and $\textit{down}$ market condition separately, instead of considering all market conditions (i.e. both $\textit{up}$ and $\textit{down}$ equally) as declared in the first form. The use of both forms for herding detection comes from an expectation that there might be periods when herding does not exist when considering both up and down market conditions at the same time but it might be found in the $\textit{up}$ or $\textit{down}$ market condition only. To this end, the same logic of the first equation is applied to the second equation wherein a significantly negative $\gamma_2$ refers to a herding signal during the $\textit{up}$ market condition while a significantly negative $\gamma_3$ refers to a herding signal during the $\textit{down}$ market condition.


---

---


**NOTE: The code below is for the entire data comprising of three types of investment vehicle as described in the paper. If you want to run herding detection on one particular type of investment vehicle only, change the "Reading Data" section at the beginning of this script to that appropriate data**

---

**Calculating CSAD and other features**

**Using 27 cryptocurrencies**
"""

csad = np.sum(np.abs(return_data - market_return_repeat), axis = 1)/num_assets

"""**Without UST**"""

csad = np.sum(np.abs(return_data_rm_UST - market_return_repeat), axis = 1)/num_assets

rmt = market_return.values
rmt_abs = np.abs(market_return.values)
rmt_squared = (market_return.values)**2
alpha = np.ones(len(market_return))
variables_csad = pd.DataFrame(data = np.asarray([csad.values, alpha, np.squeeze(rmt), np.squeeze(rmt_abs), np.squeeze(rmt_squared)]).T, columns = ["csad", "alpha", "rmt", "rmt_abs", "rmt_squared"])

variables_csad.index = market_return.index

"""# **Timeline Partition**

+ Time window 1: Start - 12.2019: [:13199]

+ Time window 2: 01.2020 - 06.2020 [13199:21935]

+ Time window 3: 07.2020 - 01.2021 [21935:32255]

+ Time window 4: 02.2021 - 08.2021 [32255:42431]

+ Time window 5: 09.2021 - 23.02.2022 [42431:50879]

+ Time window 6: 24.02.2022 - 09.2022 [50879:61391]

+ Time window 7: 10.2022 - end [61391:71711]

**Forming a regression model to estimate the parameters of the herding detection equation**

**Entire Period**
"""

X = variables_csad[['alpha', 'rmt_abs', 'rmt_squared']]
Y = variables_csad["csad"]

## fit a OLS model with intercept on TV and Radio
#X = sm.add_constant(X)
X = sm.add_constant(X)
est = sm.OLS(Y, X).fit()
est.summary()

"""**Sub-periods**"""

# start - 12/2019
X = variables_csad[['alpha', 'rmt_abs', 'rmt_squared']][:13199]
Y = variables_csad["csad"][:13199]

## fit a OLS model with intercept on TV and Radio
#X = sm.add_constant(X)
X = sm.add_constant(X)
est = sm.OLS(Y, X).fit()
est.summary()

# Time Window 2  01.2020 - 06.2020 [13199:21935]
X = variables_csad[['alpha', 'rmt_abs', 'rmt_squared']][13199:21935]
Y = variables_csad["csad"][13199:21935]

## fit a OLS model with intercept on TV and Radio
#X = sm.add_constant(X)
est = sm.OLS(Y, X).fit()
est.summary()

# Time Window 3  07.2020 - 01.2021 [21935:32255]
X = variables_csad[['alpha', 'rmt_abs', 'rmt_squared']][21935:32255]
Y = variables_csad["csad"][21935:32255]

## fit a OLS model with intercept on TV and Radio
#X = sm.add_constant(X)
est = sm.OLS(Y, X).fit()
est.summary()

# Time Window 4  02.2021 - 08.2021 [32255:42431]
X = variables_csad[['alpha', 'rmt_abs', 'rmt_squared']][32255:42431]
Y = variables_csad["csad"][32255:42431]

## fit a OLS model with intercept on TV and Radio
#X = sm.add_constant(X)
est = sm.OLS(Y, X).fit()
est.summary()

# Time Window 5  09.2021 - 23.02.2022 [42431:50879]
X = variables_csad[['alpha', 'rmt_abs', 'rmt_squared']][42431:50879]
Y = variables_csad["csad"][42431:50879]

## fit a OLS model with intercept on TV and Radio
#X = sm.add_constant(X)
est = sm.OLS(Y, X).fit()
est.summary()

# Time Window 6   24.02.2022 - 09.2022 [50879:61391]
X = variables_csad[['alpha', 'rmt_abs', 'rmt_squared']][50879:61391]
Y = variables_csad["csad"][50879:61391]

## fit a OLS model with intercept on TV and Radio
#X = sm.add_constant(X)
est = sm.OLS(Y, X).fit()
est.summary()

# Time Window 7   10.2022 - end [61391:71711]
X = variables_csad[['alpha', 'rmt_abs', 'rmt_squared']][61391:71711]
Y = variables_csad["csad"][61391:71711]

## fit a OLS model with intercept on TV and Radio
#X = sm.add_constant(X)
est = sm.OLS(Y, X).fit()
est.summary()

"""**Second Equation: CSAD for Up and Down Markets**"""

D_up_R_abs = market_return["mean market return"].apply(lambda x: x if x > 0.0 else 0.0)
D_up_R_squared = market_return["mean market return"].apply(lambda x: x**2 if x> 0.0 else 0.0)
D_down_R_abs = market_return["mean market return"].apply(lambda x: np.abs(x) if x < 0.0 else 0.0)
D_down_R_squared = market_return["mean market return"].apply(lambda x: x**2 if x < 0.0 else 0.0)
alpha = np.ones(len(market_return))

variables_csad = pd.DataFrame(data = np.asarray([csad.values, alpha, D_up_R_abs, D_up_R_squared, D_down_R_abs, D_down_R_squared]).T, columns = ["csad", "alpha", "duprabs","duprsquared","ddownrabs","ddownrsquared"])

variables_csad.index = market_return.index

market_return_repeat

"""**Entire Period**"""

X = variables_csad[['alpha', 'duprabs', 'duprsquared', 'ddownrabs', 'ddownrsquared']]
Y = variables_csad["csad"]
X = sm.add_constant(X)
est = sm.OLS(Y, X).fit()
est.summary()

"""**Sub-Period**"""

# Pre-Covid-19: start - 12/2019
X = variables_csad[['alpha', 'duprabs', 'duprsquared', 'ddownrabs', 'ddownrsquared']][:13199]
Y = variables_csad["csad"][:13199]
# X = sm.add_constant(X)
est = sm.OLS(Y, X).fit()
est.summary()

# Covid-19: 01.2020 - 06.2020 [13199:21935]
X = variables_csad[['alpha', 'duprabs', 'duprsquared', 'ddownrabs', 'ddownrsquared']][13199:21935]
Y = variables_csad["csad"][13199:21935]
# X = sm.add_constant(X)
est = sm.OLS(Y, X).fit()
est.summary()

# Bull Time 1: 07.2020 - 01.2021 [21935:32255]
X = variables_csad[['alpha', 'duprabs', 'duprsquared', 'ddownrabs', 'ddownrsquared']][21935:32255]
Y = variables_csad["csad"][21935:32255]
# X = sm.add_constant(X)
est = sm.OLS(Y, X).fit()
est.summary()

# Bull Time 2: 02.2021 - 08.2021 [32255:42431]
X = variables_csad[['alpha', 'duprabs', 'duprsquared', 'ddownrabs', 'ddownrsquared']][32255:42431]
Y = variables_csad["csad"][32255:42431]
# X = sm.add_constant(X)
est = sm.OLS(Y, X).fit()
est.summary()

# Bull Time 3: 09.2021 - 23.02.2022 [42431:50879]
X = variables_csad[['alpha', 'duprabs', 'duprsquared', 'ddownrabs', 'ddownrsquared']][42431:50879]
Y = variables_csad["csad"][42431:50879]
# X = sm.add_constant(X)
est = sm.OLS(Y, X).fit()
est.summary()

# Time window 6: 24.02.2022 - 09.2022 [50879:61391]
X = variables_csad[['alpha', 'duprabs', 'duprsquared', 'ddownrabs', 'ddownrsquared']][50879:61391]
Y = variables_csad["csad"][50879:61391]
# X = sm.add_constant(X)
est = sm.OLS(Y, X).fit()
est.summary()

# Time window 7: 10.2022 - end [61391:71711]
X = variables_csad[['alpha', 'duprabs', 'duprsquared', 'ddownrabs', 'ddownrsquared']][61391:71711]
Y = variables_csad["csad"][61391:71711]
# X = sm.add_constant(X)
est = sm.OLS(Y, X).fit()
est.summary()